"""
Implementation of the FS2 free surface boundary condition [1]

This setup reuses the SBP staggered grid operator layout for simplicity. The
idea is to treat the boundary modified region as a region of ghost points. To
update the points near the boundary, the fourth order central stencil extends
into the region of ghost points and uses these points to perform the update.

The following figure demonstrates how the ghost region and interior regions are
internally represented. There are four ghost points for each grid, but only a
few of them are ever used. Again, the reason is that we can then
reuse the interior kernel that has already been generated by the script
`kernel.py`.

         v2   0     1     2    3      4     5     6      
         z    %-----%-----%-----x-|---*-----o-----o-----o
                                  |            
         v1   0  1     2     3    |4     5     6                      
         zh   %--%-----%-----%----|x-----o-----o-----o---
                                  |
                Boundary-modified |      Interior region
                region                    

        s12   0     1     2    3      4     5     6      
          z   %-----%-----x-----x-|---*-----o-----o-----o
                                  |            
        s22   0  1     2     3    |4     5     6                      
         zh   %--%-----%-----x----|x-----o-----o-----o---
                                  |
                Boundary-modified |      Interior region
                region                    
        
            x : Used ghost point
            % : Unused ghost point
            * : Point that falls on the boundary (free surface)

    Placement of velocities and stresses on the different grids:
        s12 = s12(x, z)
        s22 = s22(xh, zh)
        v1  = v1(x, zh)
        v2  = v2(xh, z)

The free surface boundary condition is enforced by the anti-symmetry conditions

    s12(x, -z)  = -s12(x, z)
    s22(x, -z)  = -s22(x, z)

These two conditions determine all of the ghost points for the stresses. To
translate these conditions into indices, we get

    s12[4] = 0
    s12[3] = -s12[5]
    s22[4] = -s22[5]
    s22[3] = -s22[6]

Assuming symmetric velocities, we get the indices

    v1[4] = v1[5]
    v1[3] = v1[6]
    v2[3] = v2[5]
    v2[2] = v2[6]

where the indices in the x-direction have been suppressed.

The velocities are obtained by discretizing the following conditions using
second order FD approximations

    s12(x, 0) = 0
    s22(x, -h/2) = -s22(x, h/2)

Discretizing the above equations and solving for the ghost points yields
    v1(x, -h/2) = v1(x, h/2) + (v2(x+h/2, 0) - v2(x-h/2, 0))
    v2(x, -h)  = v2(x, h) + K*( v1(x+h, h/2)  - v1(x, h/2) 
                              + v1(x+h, -h/2) - v1(x, -h/2)),
            K = lam/(lam + 2*mu)

In terms of indices, we get
    v1[i, 4]     = v1[i, 5] + v2[i + 1, 4] - v2[i, 4]
    v1[i + 1, 4] = v1[i + 1, 5] + v2[i + 2, 4] - v2[i + 1, 4]
    v2[i + 1, 3] = v2[i + 1, 5] + 
                   K*(v1[i+1, 5] - v1[i, 5] + v1[i+1, 4] - v1[i, 4])


     v1   0     1     2    3      4     5     6      
     x    o-----o-----o-----o-|---o-----o-----o-----o
                              |            
     v2   0  1     2     3    |4     5     6                      
     xh   o--o-----o-----o----|x-----o-----o-----o---
                              |
            Boundary-modified |      Interior region
            region            |        


References:

 1. Gottschammer, E. and K.B. Olsen (2001). Accuracy of the Explicit Planar
    Free-Surface Boundary Condition Implemented in a Fourth-Order Staggered-Grid
    Velocity-Stress Finite-Difference Scheme, Bull. Seis. Soc. Am. 91, 617-623

"""

from openfd.cuda import make_kernel, write_kernels
from openfd import gridfunctions, Bounds, Struct, Memory, GridFunctionExpression
from openfd import grids, CArray
import openfd
import pycuda.autoinit
from helper import shifts
from sympy import  symbols, exp
from helper import shifts

class Index(GridFunctionExpression):

    def __new__(cls, expr, indices=None):
        if not indices:
            indices = (0, 0)

        if indices:
            a = str(indices)
            obj =  GridFunctionExpression.__new__(cls, expr, a) 
        else:
            obj =  GridFunctionExpression.__new__(cls, expr)

        obj.expr = expr
        obj.indices = indices
        return obj

    def __getitem__(self, indices):
        return self.expr[self.indices[0], self.indices[1]]

    def __call__(self, *indices):
        new = Index(self.expr, indices)
        return new

    def __str__(self):
        return str(self.expr)

def stress(nbnd=4):
    """

    Determine the stress at the ghost points using the imaging technique
    described above.

    Arguments:

        nbnd : Number of boundary-modified points. Defaults to `4`.

    """

    nx, ny, i,  = symbols('nx ny i')
    shape = (nx, ny)

    s12, s22 = gridfunctions('s12 s22', shape)
    t12 = Index(s12)
    t22 = Index(s22)

    out1, = gridfunctions('s12', shape, remap=lambda i : (i[0], nbnd))
    out2, = gridfunctions('s12', shape, remap=lambda i : (i[0], nbnd - 1))
    out3, = gridfunctions('s22', shape, remap=lambda i : (i[0], nbnd))
    out4, = gridfunctions('s22', shape, remap=lambda i : (i[0], nbnd - 1))

    in1 = 0*s12
    in2 = - t12(i, nbnd + 1)
    in3 = - t22(i, nbnd + 1)
    in4 = - t22(i, nbnd + 2)

    bounds = (Bounds(nx, 0, 0), Bounds(ny, 1))
    kernels = make_kernel('fs2_stress', 
                           (out1, out2, out3, out4), (in1, in2, in3, in4), 
                           bounds, shape, regions=(1, 0))
    return kernels



def velocity(nbnd=4):
    """
    Determine the velocity ghost points right next to the free surface

    Arguments:

        nbdn : Number of boundary-modified points. Defaults to `4`.

    """
    nx, ny, hi, dt = symbols('nx ny hi dt')
    shape = (nx, ny)
    rhoi, lam, mu = symbols('rhoi lam mu')

    v1, = gridfunctions('v1', shape)
    v2, = gridfunctions('v2', shape)

    i, lam_mu = symbols('i lam_mu')
    w1 = Index(v1)
    w2 = Index(v2)

    out1, = gridfunctions('v1', shape, remap=lambda i : (i[0], nbnd))
    out2, = gridfunctions('v1', shape, remap=lambda i : (i[0] + 1, nbnd))
    out3, = gridfunctions('v2', shape, remap=lambda i : (i[0] + 1, nbnd - 1))

    in1 = w1(i, nbnd + 1) + w2(i + 1, nbnd) - w2(i, nbnd)
    in2 = w1(i + 1, nbnd + 1) + w2(i + 2, nbnd) - w2(i + 1, nbnd)
    in3 = w2(i + 1, nbnd + 1) + lam_mu*(w1(i + 1, nbnd + 1) - w1(i, nbnd + 1)
                                  + w1(i + 1, nbnd) - w1(i, nbnd))

    #FIXME: Crashes
    #print(in1)
    
    bounds = (Bounds(nx, 0, 0), Bounds(ny, 1))
    kernels = make_kernel('fs2_velocity', 
                           (out1, out2, out3), (in1, in2, in3), 
                           bounds, shape, regions=(1, 0),
                           extrain=[v2], extraconst=[lam_mu])
    return kernels

def velocity_symmetric(nbnd=4):
    """
    Apply summetry conditions to the velocity field

    Arguments:

        nbdn : Number of boundary-modified points. Defaults to `4`.

    """
    nx, ny, hi, dt = symbols('nx ny hi dt')
    shape = (nx, ny)
    rhoi, lam, mu = symbols('rhoi lam mu')

    v1, = gridfunctions('v1', shape)
    v2, = gridfunctions('v2', shape)

    i, lam_mu = symbols('i lam_mu')
    w1 = Index(v1)
    w2 = Index(v2)

    # v1[4] = v1[5]
    # v1[3] = v1[6]
    # v2[3] = v2[5]
    # v2[2] = v2[6]
    out1, = gridfunctions('v1', shape, remap=lambda i : (i[0], nbnd))
    out2, = gridfunctions('v1', shape, remap=lambda i : (i[0], nbnd - 1))
    out3, = gridfunctions('v2', shape, remap=lambda i : (i[0], nbnd - 1))
    out4, = gridfunctions('v2', shape, remap=lambda i : (i[0], nbnd - 2))


    in1 = w1(i, nbnd + 1)
    in2 = w1(i, nbnd + 2)
    in3 = w2(i, nbnd + 1)
    in4 = w2(i, nbnd + 2)
                         

    #FIXME: Crashes
    #print(in1)
    
    bounds = (Bounds(nx, 0, 0), Bounds(ny, 1))
    kernels = make_kernel('sym_velocity', 
                           (out1, out2, out3, out4), (in1, in2, in3, in4), 
                           bounds, shape, regions=(1, 0)
                           )
    return kernels

def write(kernels=None, filename='kernels/fs2'):
    if not kernels:
        kernels = velocity()
        kernels += stress()
        kernels += velocity_symmetric()
    write_kernels(filename, kernels)
